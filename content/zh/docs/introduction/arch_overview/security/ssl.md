---
title: "TLS"
linkTitle: ""
weight: 1
---

Envoy supports both
[TLS termination](envoy_v3_api_field_config.listener.v3.FilterChain.transport_socket){.interpreted-text
role="ref"} in listeners as well as
[TLS origination](envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket){.interpreted-text
role="ref"} when making connections to upstream clusters. Support is
sufficient for Envoy to perform standard edge proxy duties for modern
web services as well as to initiate connections with external services
that have advanced TLS requirements (TLS1.2, SNI, etc.). Envoy supports
the following TLS features:

- **Configurable ciphers**: Each TLS listener and client can specify
  the ciphers that it supports.
- **Client certificates**: Upstream/client connections can present a
  client certificate in addition to server certificate verification.
- **Certificate verification and pinning**: Certificate verification
  options include basic chain verification, subject name verification,
  and hash pinning.
- **Certificate revocation**: Envoy can check peer certificates
  against a certificate revocation list (CRL) if one is
  [provided](envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.crl){.interpreted-text
  role="ref"}.
- **ALPN**: TLS listeners support ALPN. The HTTP connection manager
  uses this information (in addition to protocol inference) to
  determine whether a client is speaking HTTP/1.1 or HTTP/2.
- **SNI**: SNI is supported for both server (listener) and client
  (upstream) connections.
- **Session resumption**: Server connections support resuming previous
  sessions via TLS session tickets (see [RFC
  5077](https://www.ietf.org/rfc/rfc5077.txt)). Resumption can be
  performed across hot restarts and between parallel Envoy instances
  (typically useful in a front proxy configuration).
- **BoringSSL private key methods**: TLS private key operations
  (signing and decrypting) can be performed asynchronously from an
  extension. This allows extending Envoy to support various key
  management schemes (such as TPM) and TLS acceleration. This
  mechanism uses [BoringSSL private key method
  interface](https://github.com/google/boringssl/blob/c0b4c72b6d4c6f4828a373ec454bd646390017d4/include/openssl/ssl.h#L1169).

## Underlying implementation

Currently Envoy is written to use
[BoringSSL](https://boringssl.googlesource.com/boringssl) as the TLS
provider.

## FIPS 140-2 {#arch_overview_ssl_fips}

BoringSSL can be built in a [FIPS-compliant
mode](https://boringssl.googlesource.com/boringssl/+/master/crypto/fipsmodule/FIPS.md),
following the build instructions from the [Security Policy for
BoringCrypto
module](https://csrc.nist.gov/CSRC/media/projects/cryptographic-module-validation-program/documents/security-policies/140sp3318.pdf),
using `--define boringssl=fips` Bazel option. Currently, this option is
only available on Linux-x86_64.

The correctness of the FIPS build can be verified by checking the
presence of `BoringSSL-FIPS` in the `--version`{.interpreted-text
role="option"} output.

It\'s important to note that while using FIPS-compliant module is
necessary for FIPS compliance, it\'s not sufficient by itself, and
depending on the context, additional steps might be necessary. The extra
requirements may include using only approved algorithms and/or using
only private keys generated by a module operating in FIPS-approved mode.
For more information, please refer to the [Security Policy for
BoringCrypto
module](https://csrc.nist.gov/CSRC/media/projects/cryptographic-module-validation-program/documents/security-policies/140sp3318.pdf)
and/or an [accredited CMVP
laboratory](https://csrc.nist.gov/projects/testing-laboratories).

Please note that the FIPS-compliant build is based on an older version
of BoringSSL than the non-FIPS build, and it predates the final version
of TLS 1.3.

## Enabling certificate verification {#arch_overview_ssl_enabling_verification}

Certificate verification of both upstream and downstream connections is
not enabled unless the validation context specifies one or more trusted
authority certificates.

### Example configuration

```{.yaml}
static_resources:
  listeners:
  - name: listener_0
    address: { socket_address: { address: 127.0.0.1, port_value: 10000 } }
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        # ...
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
          common_tls_context:
            validation_context:
              trusted_ca:
                filename: /usr/local/my-client-ca.crt
  clusters:
  - name: some_service
    connect_timeout: 0.25s
    type: STATIC
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: some_service
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: 127.0.0.2
                port_value: 1234
    transport_socket:
      name: envoy.transport_sockets.tls
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
        common_tls_context:
          tls_certificates:
            certificate_chain: { "filename": "/cert.crt" }
            private_key: { "filename": "/cert.key" }
          validation_context:
            match_subject_alt_names:
              exact: "foo"
            trusted_ca:
              filename: /etc/ssl/certs/ca-certificates.crt
```

_/etc/ssl/certs/ca-certificates.crt_ is the default path for the system
CA bundle on Debian systems.
[trusted_ca](envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca){.interpreted-text
role="ref"} along with
[match_subject_alt_names](envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_subject_alt_names){.interpreted-text
role="ref"} makes Envoy verify the server identity of _127.0.0.2:1234_
as \"foo\" in the same way as e.g. cURL does on standard Debian
installations. Common paths for system CA bundles on Linux and BSD are:

- /etc/ssl/certs/ca-certificates.crt (Debian/Ubuntu/Gentoo etc.)
- /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem (CentOS/RHEL 7)
- /etc/pki/tls/certs/ca-bundle.crt (Fedora/RHEL 6)
- /etc/ssl/ca-bundle.pem (OpenSUSE)
- /usr/local/etc/ssl/cert.pem (FreeBSD)
- /etc/ssl/cert.pem (OpenBSD)

See the reference for
[UpstreamTlsContexts](envoy_v3_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext){.interpreted-text
role="ref"} and
[DownstreamTlsContexts](envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext){.interpreted-text
role="ref"} for other TLS options.

::: {.attention}
::: {.admonition-title}
Attention
:::

If only
[trusted_ca](envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca){.interpreted-text
role="ref"} is specified, Envoy will verify the certificate chain of the
presented certificate, but not its subject name, hash, etc. Other
validation context configuration is typically required depending on the
deployment.
:::

## Certificate selection {#arch_overview_ssl_cert_select}

[DownstreamTlsContexts](envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext){.interpreted-text
role="ref"} support multiple TLS certificates. These may be a mix of RSA
and P-256 ECDSA certificates. The following rules apply:

- Only one certificate of a particular type (RSA or ECDSA) may be
  specified.
- Non-P-256 server ECDSA certificates are rejected.
- If the client supports P-256 ECDSA, a P-256 ECDSA certificate will
  be selected if present in the
  [DownstreamTlsContext](envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext){.interpreted-text
  role="ref"}.
- If the client only supports RSA certificates, a RSA certificate will
  be selected if present in the
  [DownstreamTlsContext](envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext){.interpreted-text
  role="ref"}.
- Otherwise, the first certificate listed is used. This will result in
  a failed handshake if the client only supports RSA certificates and
  the server only has ECDSA certificates.
- Static and SDS certificates may not be mixed in a given
  `DownstreamTlsContext <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext>`{.interpreted-text
  role="ref"}.

Only a single TLS certificate is supported today for
`UpstreamTlsContexts <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext>`{.interpreted-text
role="ref"}.

## Secret discovery service (SDS)

TLS certificates can be specified in the static resource or can be
fetched remotely. Certificate rotation is supported for static resources
by sourcing
[SDS configuration from the filesystem](xds_certificate_rotation){.interpreted-text
role="ref"} or by pushing updates from the SDS server. Please see
[SDS](config_secret_discovery_service){.interpreted-text role="ref"}
for details.

## Authentication filter {#arch_overview_ssl_auth_filter}

Envoy provides a network filter that performs TLS client authentication
via principals fetched from a REST VPN service. This filter matches the
presented client certificate hash against the principal list to
determine whether the connection should be allowed or not. Optional IP
allowlisting can also be configured. This functionality can be used to
build edge proxy VPN support for web infrastructure.

Client TLS authentication filter `configuration reference <config_network_filters_client_ssl_auth>`{.interpreted-text role="ref"}.

## Trouble shooting {#arch_overview_ssl_trouble_shooting}

When Envoy originates TLS when making connections to upstream clusters,
any errors will be logged into
`UPSTREAM_TRANSPORT_FAILURE_REASON<config_access_log_format_upstream_transport_failure_reason>`{.interpreted-text
role="ref"} field or
`AccessLogCommon.upstream_transport_failure_reason<envoy_v3_api_field_data.accesslog.v3.AccessLogCommon.upstream_transport_failure_reason>`{.interpreted-text
role="ref"} field. Common errors are:

- `Secret is not supplied by SDS`: Envoy is still waiting SDS to
  deliver key/cert or root CA.
- `SSLV3_ALERT_CERTIFICATE_EXPIRED`: Peer certificate is expired and
  not allowed in config.
- `SSLV3_ALERT_CERTIFICATE_UNKNOWN`: Peer certificate is not in config
  specified SPKI.
- `SSLV3_ALERT_HANDSHAKE_FAILURE`: Handshake failed, usually due to
  upstream requires client certificate but not presented.
- `TLSV1_ALERT_PROTOCOL_VERSION`: TLS protocol version mismatch.
- `TLSV1_ALERT_UNKNOWN_CA`: Peer certificate CA is not in trusted CA.

More detailed list of error that can be raised by BoringSSL can be found
[here](https://github.com/google/boringssl/blob/master/crypto/err/ssl.errordata)
